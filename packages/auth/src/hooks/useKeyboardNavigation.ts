'use client'

import { useCallback, useEffect, RefObject } from 'react'

interface KeyboardNavigationOptions {\n  onEscape?: () => void\n  onEnter?: () => void\n  onArrowUp?: () => void\n  onArrowDown?: () => void\n  onArrowLeft?: () => void\n  onArrowRight?: () => void\n  onHome?: () => void\n  onEnd?: () => void\n  onTab?: (event: KeyboardEvent) => void\n  preventDefault?: string[]\n  enabled?: boolean\n}\n\nexport function useKeyboardNavigation(\n  elementRef: RefObject<HTMLElement>,\n  options: KeyboardNavigationOptions = {}\n) {\n  const {\n    onEscape,\n    onEnter,\n    onArrowUp,\n    onArrowDown,\n    onArrowLeft,\n    onArrowRight,\n    onHome,\n    onEnd,\n    onTab,\n    preventDefault = [],\n    enabled = true\n  } = options\n\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    if (!enabled) return\n\n    const { key } = event\n\n    // Prevent default for specified keys\n    if (preventDefault.includes(key)) {\n      event.preventDefault()\n    }\n\n    switch (key) {\n      case 'Escape':\n        onEscape?.()\n        break\n      case 'Enter':\n        onEnter?.()\n        break\n      case 'ArrowUp':\n        onArrowUp?.()\n        break\n      case 'ArrowDown':\n        onArrowDown?.()\n        break\n      case 'ArrowLeft':\n        onArrowLeft?.()\n        break\n      case 'ArrowRight':\n        onArrowRight?.()\n        break\n      case 'Home':\n        onHome?.()\n        break\n      case 'End':\n        onEnd?.()\n        break\n      case 'Tab':\n        onTab?.(event)\n        break\n    }\n  }, [\n    enabled,\n    onEscape,\n    onEnter,\n    onArrowUp,\n    onArrowDown,\n    onArrowLeft,\n    onArrowRight,\n    onHome,\n    onEnd,\n    onTab,\n    preventDefault\n  ])\n\n  useEffect(() => {\n    const element = elementRef.current\n    if (!element || !enabled) return\n\n    element.addEventListener('keydown', handleKeyDown)\n    return () => element.removeEventListener('keydown', handleKeyDown)\n  }, [elementRef, handleKeyDown, enabled])\n\n  return { handleKeyDown }\n}\n\n// Helper for roving tabindex pattern\nexport function useRovingTabIndex(\n  containerRef: RefObject<HTMLElement>,\n  itemSelector: string = '[role=\"option\"], [role=\"menuitem\"], [role=\"tab\"]',\n  options: {\n    orientation?: 'horizontal' | 'vertical' | 'both'\n    wrap?: boolean\n    enabled?: boolean\n  } = {}\n) {\n  const { orientation = 'vertical', wrap = true, enabled = true } = options\n\n  const getCurrentIndex = useCallback(() => {\n    if (!containerRef.current) return -1\n    const items = Array.from(containerRef.current.querySelectorAll(itemSelector))\n    const activeElement = document.activeElement\n    return items.findIndex(item => item === activeElement)\n  }, [containerRef, itemSelector])\n\n  const focusItem = useCallback((index: number) => {\n    if (!containerRef.current) return\n    const items = Array.from(containerRef.current.querySelectorAll<HTMLElement>(itemSelector))\n    const item = items[index]\n    if (item) {\n      // Update tabindex\n      items.forEach((item, i) => {\n        item.tabIndex = i === index ? 0 : -1\n      })\n      item.focus()\n    }\n  }, [containerRef, itemSelector])\n\n  const moveToNext = useCallback(() => {\n    if (!containerRef.current) return\n    const items = Array.from(containerRef.current.querySelectorAll(itemSelector))\n    const currentIndex = getCurrentIndex()\n    const nextIndex = currentIndex === items.length - 1 \n      ? (wrap ? 0 : currentIndex)\n      : currentIndex + 1\n    focusItem(nextIndex)\n  }, [containerRef, itemSelector, getCurrentIndex, focusItem, wrap])\n\n  const moveToPrevious = useCallback(() => {\n    if (!containerRef.current) return\n    const items = Array.from(containerRef.current.querySelectorAll(itemSelector))\n    const currentIndex = getCurrentIndex()\n    const prevIndex = currentIndex === 0 \n      ? (wrap ? items.length - 1 : 0)\n      : currentIndex - 1\n    focusItem(prevIndex)\n  }, [containerRef, itemSelector, getCurrentIndex, focusItem, wrap])\n\n  const moveToFirst = useCallback(() => {\n    focusItem(0)\n  }, [focusItem])\n\n  const moveToLast = useCallback(() => {\n    if (!containerRef.current) return\n    const items = Array.from(containerRef.current.querySelectorAll(itemSelector))\n    focusItem(items.length - 1)\n  }, [containerRef, itemSelector, focusItem])\n\n  useKeyboardNavigation(containerRef, {\n    onArrowDown: orientation === 'vertical' || orientation === 'both' ? moveToNext : undefined,\n    onArrowUp: orientation === 'vertical' || orientation === 'both' ? moveToPrevious : undefined,\n    onArrowRight: orientation === 'horizontal' || orientation === 'both' ? moveToNext : undefined,\n    onArrowLeft: orientation === 'horizontal' || orientation === 'both' ? moveToPrevious : undefined,\n    onHome: moveToFirst,\n    onEnd: moveToLast,\n    preventDefault: ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End'],\n    enabled\n  })\n\n  return {\n    getCurrentIndex,\n    focusItem,\n    moveToNext,\n    moveToPrevious,\n    moveToFirst,\n    moveToLast\n  }\n}